<div class="row">
<div class="col-md-3 visible-md visible-lg" style="height: 100%;">
    <div class="sidebar hidden-print affix-top" role="complementary" data-affix="0">
        <div style="padding: 40px 0 0 15px;">
            <ul class="nav nav-tabs nav-stacked" style="border: 0;" data-ng-repeat="link in links">
                <li>
                    <a data-ng-href="{{link.target}}" data-du-smooth-scroll="" data-du-scrollspy="" data-offset="40">
                        {{link.name}}
                    </a>
                </li>
            </ul>
        </div>
    </div>
</div>
<div class="visible-xs visible-sm">
    <div class="hidden-print" role="complementary">
        <ul class="nav nav-tabs nav-stacked" style="border: 0;" data-ng-repeat="link in links">
            <li>
                <a data-ng-href="{{link.target}}" data-du-smooth-scroll="" data-du-scrollspy="" data-offset="40">
                    {{link.name}}
                </a>
            </li>
        </ul>
    </div>
</div>
<div class="col-md-8 col-md-offset-1" id="affixComponent">
<div class="row" style="background-color: orange; font-weight: bold; color: #ffffff; padding: 5px;">
    This tutorial is currently in the make. We hope to publish a first release of Byte
    Buddy together with the completed version of this tutorial and web page before July 2014!
</div>
<div class="row" id="rational">

<h2>Why runtime code generation?</h2>

<p>
    The Java language comes with a comparatively strict type system. Java requires all variables and objects to be of a
    specific type and an attempt to assign incompatible types will always cause an error. These errors are usually
    emitted by the Java compiler or at the very least by the Java runtime. This behavior is great for writing business
    applications because business domains can usually be described in such an explicit manner. This way, we can use Java
    to build very readable and robust applications. Among other things, it is Java's type system that is responsible for
    Java's popularity in enterprise programming.
</p>

<p>
    However, by enforcing its strict type system, Java imposes limitations that restrict the language's
    scope of use in other domains. For example, when writing a library that is to be used by other Java
    applications, we are normally not able to use any type that is defined in the user's application
    because these types are unknown to us when our library is compiled. In order to call methods or access
    fields of the user's code, the Java Class Library comes with a reflection API. Using the reflection API,
    we are able to introspect unknown types and to call methods or access fields. Unfortunately, the use of
    the reflection API has two significant downsides:
</p>
<ul class="colored-list padded">
    <li><span>
        Using the reflection API is
        <a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">slower</a> than a hard-coded method
        invocation: First, one needs to perform a rather expensive method lookup to get hold of an object that
        describes a specific method. And when a method is invoked, this requires the JVM to run native code
        which requires long run time compared to a direct invocation. However, modern JVMs know a concept called
        <a href="https://blogs.oracle.com/buck/entry/inflation_system_properties">inflation</a> where the
        JNI-based method invocation is replaced by generated byte code that is injected into a dynamically
        created class. As you can see, even the JVM itself uses code generation!
    </span></li>
    <li><span>
        The reflection API breaks type-safety: Even though the JVM is capable of improving the reflective
        runtime, we might be required to expose this reflective API to our library's users when enhancing
        the user types. However, type-safety is one of Java's strong suites. We do not want to take it away when
        interacting with out user's code. To get a better understanding of this problem, let us look at the example
        of a miniature security library.
    </span></li>
</ul>
<h4>Writing a security library</h4>

<p>
    Business applications can grow large and sometimes it is difficult to keep an overview of call stacks
    in our application. This can become problematic when we have crucial methods in our application that should
    only be called under specific conditions. Imagine a business application that implements a reset
    functionality that allows deleting everything from the application's database.
</p>
<pre class="prettyprint">class Service {
  void deleteEverything() {
    // delete everything ...
  }
}</pre>
<p>
    Such a reset should of course only be performed by administrators and never by a normal user of our
    application. By analyzing our source code, we could of course make sure that this will never happen. However,
    we can expect our application to grow and to be changed in the future. Therefore, we want to implement
    a tighter security model where the method invocation is guarded by an explicit check for the application's
    current user. We will normally use a security framework for making sure that the method is never called by
    anybody but by an administrator.
</p>

<p>
    For this purpose, assume that we are using a security framework with a public API as the following:
</p>
<pre class="prettyprint">@interface Secured {
  String user();
}

class UserHolder {
  static String user;
}

interface Framework {
  &lt;T&gt; T secure(Class&lt;T&gt; type);
}</pre>
<p>
    In this framework, the <code>Secured</code> annotation should be used to mark methods that can only be
    accessed by a given user. The <code>UserHolder</code> is used for globally defining which user is
    currently logged into the application. The <code>Framework</code> interface allows for the creation of
    secured instances by calling the default constructor of a given type. Of course, this framework is overly
    simple, but in principal this is how security frameworks like for example the popular
    <a href="http://projects.spring.io/spring-security/">Spring Security</a> work. A feature of this
    security framework is that we preserve the user's types. By the contract of our framework interface, we
    promise the user to return an instance of any type <code>T</code> it receives. Thanks to this,
    a user is able to interact with his own types as if the security framework did not exist. In a test
    environment, a user could even create unsecured instances of his types and use these instances instead of the
    secured ones. You will agree that this is really handy! Such frameworks are known to interact with
    <i>POJOs</i>, plain old Java objects, a term that was coined for describing non-intrusive frameworks that do
    not impose their own types upon their users.
</p>

<p>
    Imagine for now that we knew that the type handed to the <code>Framework</code> could only be <code>T =
    Service</code> and that the <code>deleteEverything</code> method was annotated with
    <code>@Secured("ADMIN")</code>. This way, we could easily implement a secured version of this particular type by
    simply subclassing it:
</p>
<pre class="prettyprint">class SecuredService extends Service {
  @Override
  void deleteEverything() {
    if(UserHolder.user.equals("ADMIN")) {
      super.deleteEverything();
    } else {
      throw new IllegalStateException("Not authorized");
    }
  }
}</pre>
<p>
    With this additional class we could implement the framework as follows:
</p>
<pre class="prettyprint">class HardcodedFrameworkImpl implements Framework {
  @Override
  public &lt;T&gt; T secure(Class&lt;T&gt; type) {
    if(type == Service.class) {
      return (T) new SecuredService();
    } else {
      throw new IllegalArgumentException("Unknown: " + type);
    }
  }
}</pre>
<p>
    Of course, this implementation is not of much use. By the <code>secure</code> method's signature we suggested
    that the method can provide security for any type but in reality, we will throw an exception once we encounter
    something else then the known <code>Service</code>. Also, this would require our security library to know
    about about this particular <code>Service</code> type when the library is compiled. Obviously, this is not a
    feasible solution for implementing the framework. So how can we solve this problem? Well, since this is a
    tutorial on a code generation library you will have guessed the answer: We create a subclass on demand
    and at runtime when the <code>Service</code> class first becomes known to our security framework by the
    invocation of the <code>secure</code> method. With code generation, we can take any given type, subclass it at
    runtime and override the methods we want to secure. In our case, we override all methods that are annotated
    with <code>@Secured</code> and read the required user from the annotation's <code>user</code> property. Many
    popular Java frameworks are implemented using a similar approach.
</p>

<h4>General information</h4>

<p>
    Before we learn all about code generation and Byte Buddy, note that you should use code generation with
    care. Java types are something rather special to the JVM and are often not garbage collected. Therefore, you
    should never overuse code generation but only solve problems using generated code when it is the only way
    out. However, if you need to enhance unknown types as in the previous example, code generation is most likely your
    only option. Frameworks for security, transaction management, object-relational mapping or mocking are typical
    users of code generation libraries.
</p>

<p>
    Of course, Byte Buddy is not the first library for code generation on the JVM. However, we believe that Byte Buddy
    knows some tricks the other frameworks cannot apply. The overall objective of Byte Buddy is to work declaratively,
    both by focusing on its domain specific language and the use of annotations. No other code generation library for
    the JVM we know of works this way. Nevertheless, you might want to have a look at some other frameworks for code
    generation to find out which one suites you best:
</p>

<dl class="dl-horizontal padded">
    <dt>
        <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html">Java proxies</a>
    </dt>
    <dd>
        The Java Class Library comes with a proxy toolkit that allows for the creation of classes that implement a given
        set of interfaces. This built-in proxy supplier is handy but also very limited. The above mentioned security
        framework could for example not be implemented this way since we want to extend classes and not interfaces.
    </dd>
    <dt>
        <a href="http://cglib.sourceforge.net/">cglib</a>
    </dt>
    <dd>
        The <i>code generation library</i> was implemented during the early years of Java and it did unfortunately not
        keep up with the development of the Java platform. Nevertheless, cglib remains a quite powerful library but its
        active development became rather vague. For this reason, many of its users moved away from cglib.
    </dd>
    <dt>
        <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/">javassist</a>
    </dt>
    <dd>
        This library comes with a compiler that takes strings containing Java source code which are translated into Java
        byte code during the runtime of an application. This is very ambitious and in principle a great idea since Java
        source code is obviously a great way for describing Java classes. However, the javassist compiler does not
        compare to the javac compiler in its functionality and allows for easy mistakes when dynamically composing
        strings to implement more complex logic. Additionally, javassist comes with a proxy library which is similar to
        the JCL's proxy utilities but allows extending classes and is not limited to interfaces. The scope of
        javassist's proxy tools remain however equally limited in its API and functionality.
    </dd>
    <dt>
        <a href="http://jodd.org/doc/proxetta/">Proxetta</a>
    </dt>
    <dd>
        Proxetta is a module of the Jodd framework and a rather young player in the code generation game. Proxetta
        focuses on the creation of proxies and can be considered as similar to cglib in its approach.
    </dd>
</dl>

<p>
    Evaluate the frameworks for yourself but we believe that Byte Buddy offers functionality and convenience that you
    will otherwise search in vain. Byte Buddy comes with an expressive domain specific language that allows for the
    creation of very custom runtime classes by writing plain Java code and by using strong typing for your own code.
    At the same time, Byte Buddy is very open for customization and does not restrain you to the features that come out
    of the box. If required, you can even define custom byte code for any implemented method. But even without knowing
    what byte code is or how it works, you are able to do quite a lot without digging deep into the framework. Did
    you for example have a look at the <a href="#/#helloworld"><code>Hello World!</code> example</a>? Using Byte Buddy
    is that easy.
</p>

<p>
    In the following tutorial we will gradually explain the features of Byte Buddy. We will start with its more general
    features which are most likely used by a majority of users. We will then consider increasingly advanced topics and
    give a short introduction to Java byte code and the class file format. And don't be discouraged in case you fast
    forward to this later material! You can do almost anything by using Byte Buddy's standard API and without
    understanding any JVM specifics. For learning about the standard API, just read on.
</p>
</div>
<div class="row" id="gettingstarted">
    <h2>Creating a class</h2>

    <p>
        Any type that is created by Byte Buddy is emitted by an instance of the <code>ByteBuddy</code> class. Simply
        create a new instance by calling <code>new ByteBuddy()</code> and you are ready to go. Hopefully, you are using
        an development environment where you get suggestions on the methods that you can call on a given object. This
        way, you can avoid to manually look up a class's API in <a href="javadoc/v0_1/index.html">Byte Buddy's
        javadoc</a> but have your IDE guide you through the process. As mentioned before, Byte Buddy offers a domain
        specific language which intends to be as human-readable as possible. Your IDE's hints will therefore point you
        into the right direction most of the time. But enough of the talking, let us create a first class at a Java
        program's runtime:
    </p>
<pre class="prettyprint">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .make();
</pre>
    <p>
        As it is hopefully obvious, the above code example creates a new class that extends the <code>Object</code>
        type.
        This dynamically created type would be equivalent to a Java class that only extends <code>Object</code> without
        explicitly implementing any methods, fields or constructors. You might have noted that we did not even name the
        dynamically generated type, something that normally is required when defining a Java class. Of course, you could
        have easily named your type explicitly:
    </p>
<pre class="prettyprint">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()
  .subclass(Object.class)
  .name("example.Type")
  .make();
</pre>
    <p>
        But what happens without the explicit naming? Byte Buddy lives and breaths of
        <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">convention over configuration</a> and
        provides you with defaults that we found convenient. As for the name of a type, the default Byte Buddy
        configuration provides a <code>NamingStrategy</code> which randomly creates a class name based on a dynamic
        type's superclass name. Furthermore, the name is defined to be in the same package as the subclass such
        that package-private methods of the direct superclass are always visible to the dynamic type. If you for example
        subclassed a type named <code>example.Foo</code>, the generated name will be something like
        <code>example.Foo$$ByteBuddy$$1376491271</code> where the numeric sequence is random. An exception of this rule
        is made when subclassing types from the <code>java.lang</code> package where types such as <code>Object</code>
        live. Java's security model does not allow custom types to live is this namespace. Therefore, such type names
        are prefixed with <code>net.bytebuddy.renamed</code> by the default naming strategy.
    </p>

    <p>
        This default behavior might not be convenient for you. And thanks to the convention over configuration
        principle, you can always alter the default behavior by your needs. This is where the <code>ByteBuddy</code>
        class comes into place. By creating a <code>new ByteBuddy()</code> instance, you create a default configuration.
        By calling methods on this configuration, you can customize it by your individual needs. Let's try this:
    </p>
<pre class="prettyprint">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()
  .withNamingStrategy(new NamingStrategy() {
    @Override
    public String getName(UnnamedType unnamedType) {
        return "i.love.ByteBuddy." + unnamedType.getSuperClass().getSimpleName();
    }
  })
  .subclass(Object.class)
  .make();
</pre>
    <p>
        In the above code example, we created a new configuration that differs from the default configuration in its
        type naming strategy. The anonymous class is implemented to simply concatenate the string
        <code>i.love.ByteBuddy</code> and the base class's simple name. When subclassing the
        <code>Object</code> type, the dynamic type is therefore named <code>i.love.ByteBuddy.Object</code>. Be however
        careful
        when creating your own naming strategies! The Java virtual machine uses names to distinguish between types
        which is why you want to avoid naming collisions. If you need to customize the naming behavior, consider
        using Byte Buddy's built-in <code>NamingStrategy.SuffixingRandom</code> which you can customize to include
        a prefix that is more meaningful to your application than our default.
    </p>

    <h4>Domain specific language and immutability</h4>

    <p>
        After seeing Byte Buddy's domain specific language in action, we need to have a short look at the way this
        language is implemented. The one detail you need to know about the implementation is that the language is built
        around <a href="http://en.wikipedia.org/wiki/Immutable_object">immutable objects</a>. As a matter of fact,
        almost every class that lives in the Byte Buddy namespace was made immutable and in the few cases we could not
        make a type immutable, we explicitly mention it in this class's javadoc. If you implement custom
        features for Byte Buddy, we recommend you to stick with this principle.
    </p>

    <p>
        As an implication of the mentioned immutability, you must be careful when for example configuring
        <code>ByteBuddy</code> instances. You might for example make the following mistake:
    </p>
<pre class="prettyprint">ByteBuddy byteBuddy = new ByteBuddy();
byteBuddy.withNamingStrategy(new NamingStrategy.SuffixingRandom("suffix"));
DynamicType.Unloaded&lt;?&gt; dynamicType = byteBuddy.subclass(Object.class).make();
</pre>
    <p>
        You might expect the dynamic type to be generated using the custom naming strategy <code>new
        NamingStrategy.SuffixingRandom("suffix")</code> that was (allegedly) defined. Instead of mutating the
        instance that is stored in the <code>byteBuddy</code> variable, the invocation of the
        <code>withNamingStrategy</code> method returns a customized <code>ByteBuddy</code> instance which is however
        lost. As a result, the dynamic type is created using the default configuration which was originally created.
    </p>

    <h4>Loading a class</h4>

    <p>
        So far we only have defined and created a dynamic type but we did not make any use of it. A type that is
        created by Byte Buddy is represented by an instance of <code>DynamicType.Unloaded</code>. As the name
        suggests, these types are not loaded into the Java virtual machine. Instead, classes created by Byte Buddy are
        represented in their binary form, in the
        <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">Java class file format</a>. This way,
        it is up to you to decide what you want to do with a generated class. For example, you might want to run
        Byte Buddy from a build script that only generates classes to enhance a Java application before it is deployed.
        For this purpose, the <code>DynamicType.Unloaded</code> class allows to extract a byte array that represents
        the dynamic type. For convenience, the type additionally offers a <code>saveIn(File)</code> method that allows
        you to store a class in a given folder.
    </p>

    <p>
        While directly accessing a class's binary form is straight forward, loading a type is unfortunately more
        complex. In Java, all classes are loaded using a <code>ClassLoader</code>. One example for such a class loader
        is the bootstrap class loader which is responsible for loading the classes of the Java Class Library. The
        system class loader, on the other hand, is responsible for loading classes on the Java application's class path.
        Obviously, none of these preexisting class loaders is aware of any dynamic class we have created. To overcome
        this, we have to find other possibilities for loading a runtime generated class. Byte Buddy offers solutions by
        two different approaches out of the box:
    </p>

    <ul class="colored-list padded">
        <li><span>
            We simply create a new <code>ClassLoader</code> which is explicitly told about the existence of a
            particular dynamically created class. Because
            Java class loaders are organized in hierarchies, we define this class loader as the child of a given class
            loader that already exists in the running Java application. This way, all types of the running Java
            program is visible to the dynamic type that was loaded with new new <code>ClassLoader</code>.
        </span></li>
        <li><span>
            We can use reflection to inject a new type into an existent class loader. Usually, a class loader is asked
            to provide a given type by its name. Using reflection, we can turn this principle around and call a
            protected method to inject a new class into the class loader without the class loader actually knowing how
            to locate this dynamic class.
        </span></li>
    </ul>

    <p>
        Unfortunately, both approaches have downsides.
    </p>

    <ul class="colored-list padded">
        <li><span>
            If we create a new <code>ClassLoader</code>, this class loader defines a new namespace. As an implication,
            it is possible to load two classes with identical name as long as these classes are loaded by two different
            class loaders. These two classes are then never be considered as equal by a Java virtual machine, even if
            both classes represent an identical class implementation. This rule for equality holds however also for Java
            packages. This means that a class <code>example.Foo</code> is not able to access package-private
            methods of another class <code>example.Bar</code> if both classes were not loaded with the same class loader.
            Also, if <code>example.Bar</code> extended <code>example.Foo</code>, any overriden package-private methods
            would become inoperative but would delegate to the original implementations.
        </span></li>
        <li><span>
            Whenever a class is loaded, its class loader will look up any type that is referenced in this class
            once a code segment referencing another type is is resolved. This lookup delegates to the same class loader.
            Imagine a scenario where we dynamically created two classes <code>example.Foo</code> and <code>example.Bar</code>.
            If we injected <code>example.Foo</code> into an existent class loader, this class loader might attempt to
            locate <code>example.Bar</code>. This lookup will however fail since the latter class was created dynamically
            and is unreachable for the class loader into which we just injected the <code>example.Foo</code> class.
            Therefore, the reflective approach cannot be used for classes with circular dependencies that become
            effective during class loading.
        </span></li>
    </ul>

    <p>
        You might consider the chance of encountering circular dependencies to be of minor relevance since you
        are creating one dynamic type at a time. However, the dynamic creation of a type might trigger the creation of
        so-called auxiliary types. These types are created by Byte Buddy automatically to provide access to the dynamic
        type you are creating. We learn more about auxiliary types in the following section, do not worry about
        them for now. However, because of this, we recommend you to load dynamically created classes by creating a
        specific <code>ClassLoader</code> instead of injecting them into an existing one, whenever possible.
    </p>

    <p>
        After creating a <code>DynamicType.Unloaded</code>, this type can be loaded using a
        <code>ClassLoadingStrategy</code>. Byte Buddy provides two such strategies out of the box where each follows
        one of the concepts that were described above. These strategies are defined in <code>ClassLoadingStrategy.Default</code>
        where the <code>WRAPPER</code> strategy creates a new <code>ClassLoader</code> and the
        <code>INJECTION</code> strategy attempts to inject a dynamic type using reflection. Let's look at such class
        loading in action:
    </p>
<pre class="prettyprint">Class&lt;?&gt; type = new ByteBuddy()
  .subclass(Object.class)
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded();
</pre>
    <p>
        In the above example, we have created and loaded a class. We used the <code>WRAPPER</code> strategy for loading
        the class which is suitable for most cases, as we mentioned it before. However, for this easy class creation,
        the <code>INJECTION</code> strategy would have worked as well. Finally, the <code>getLoaded</code> method
        returns an instance of a Java <code>Class</code> that represents the dynamic class which is now loaded.
    </p>
</div>
<div class="row" id="members">
<h2>Fields and methods</h2>

<p>
    The type we created in the previous section did not define any fields or methods. However, by subclassing
    <code>Object</code>, it inherits the methods that are defined by its super class. Let us verify this Java
    trivia and call the <code>toString</code> method on an instance of the dynamic type. We can get hold of an
    instance by calling the created class's constructor reflectively.
</p>
<pre class="prettyprint">String toString = new ByteBuddy()
  .subclass(Object.class)
  .name("example.Type")
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded()
  .newInstance() // Java reflection API
  .toString();
</pre>
<p>
    The implementation of the <code>Object#toString</code> method returns the concatenation of the instance's fully
    qualified class name and the hex representation of the instance's hash code. And in fact, invoking the
    <code>toString</code> method on the created instance returns something like <code>example.Type@340d1fa5</code>.
</p>

<p>
    Of course, we are not done here. The main motivation of creating dynamic classes is the ability to define new
    logic. To demonstrate how this is done, let us start with something simple. We want to override the
    <code>toString</code> method and return <code>Hello World!</code> instead of the previous default value:
</p>
<pre class="prettyprint">String toString = new ByteBuddy()
  .subclass(Object.class)
  .name("example.Type")
  .method(named("toString")).intercept(FixedValue.value("Hello World!"))
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded()
  .newInstance()
  .toString();
</pre>
<p>
    The line we added to our code contains two instructions in Byte Buddy's domain specific language. The first
    instruction is <code>method</code> which allows us to select any number of methods that we want to override.
    This selection is applied by handing over a <code>MethodMatcher</code> which serves as a predicate to decide
    for each overridable method if it should be overriden or not. Byte Buddy comes with a lot of predefined method
    matchers which are collected in the <code>MethodMatchers</code> class. Normally, you would import this class
    statically such that the resulting code reads more naturally. Such a static import was also assumed for the
    above example where we used the <code>named</code> method matcher which selects methods by their exact names.
    Note that the predefined method matchers are composable. This way, we could have described the method selection
    in further detail such as by:
</p>
<pre class="prettyprint">named("toString").and(returns(String.class)).and(takesArguments(0))</pre>
<p>
    This latter method matcher describes the <code>toString</code> method by its full Java signature and therefore
    only matches this particular method. However, in the given context we know that there is no other method
    named <code>toString</code> with a different signature such that our original method matcher is sufficient.
</p>

<p>
    After selecting the <code>toString</code> method, the second instruction <code>intercept</code> determines
    the implementation that should override all methods of the given selection. In order to know how to implement a
    method, this instruction requires a single argument of type <code>Instrumentation</code>. In the above example,
    we are making use of the <code>FixedValue</code> instrumentation which ships with Byte Buddy. As suggested by
    this class's name, the instrumentation implements a method to always return a given value. We will have a more
    detailed look at the <code>FixedValue</code> instrumentation a little later in this section. Right now, let us
    rather look a little closer at the method selection.
</p>

<p>
    So far, we only intercepted a single method. In real applications, things might however be more complicated and
    we might want to apply different rules for overriding different methods. Let us look at an example of such a
    scenario:
</p>
<pre class="prettyprint">class Foo {
  public String bar() { return null; }
  public String foo() { return null; }
  public String foo(Object o) { return null; }
}

Foo dynamicFoo = new ByteBuddy()
  .subclass(Foo.class)
  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value("One!"))
  .method(named("foo")).intercept(FixedValue.value("Two!"))
  .method(named("foo").and(takesArguments(1))).intercept(FixedValue.value("Three!"))
  .make()
  .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
  .getLoaded()
  .newInstance();
</pre>
<p>
    In the above example, we defined three different rules for overriding methods. When investigating the code, you
    will notice that the first rule concerns any method that is defined by <code>Foo</code>, i.e. all three
    methods in the example class. The second rule matches both methods that are named <code>foo</code>, a subset of
    the previous selection. And the last rule only matches the <code>foo(Object)</code> method which is a
    further reduction of the former selection. But given this selection overlap, how does Byte Buddy decide which rule
    is applied to which method?
</p>

<p>
    Byte Buddy organizes rules for overriding methods in a stack form. This means that whenever you register a new
    rule for overriding a method, Ã­t is pushed on the top of this stack and is always applied first until a new rule
    is added which will then be of even higher priority. For the above example, this means that:
</p>

<ul class="colored-list padded">
    <li><span>
            The <code>bar()</code> method is first matched against <code>named("foo").and(takesArguments(1))</code>
            and then against <code>named("foo")</code> where both matching attempts turn out negative. Finally, the
            <code>isDeclaredBy(Foo.class)</code> matcher gives green light to override the <code>bar()</code> method to
            return <code>One!</code>.
        </span></li>
    <li><span>
            Similarly, the <code>foo()</code> method is first matched against
            <code>named("foo").and(takesArguments(1))</code> first where the missing argument results in an unsuccessful
            matching. After this, the <code>named("foo")</code> matcher determines a positive match such that the
            <code>foo()</code> method is overriden to return <code>Two!</code>.
        </span></li>
    <li><span>
            The <code>foo(Object)</code> is immediately matched by the <code>named("foo").and(takesArguments(1))</code>
            matcher such that the overriden implementation returns <code>Three!</code>.
        </span></li>
</ul>
<p>
    Because of this organizations, you should always register more specific method matchers last. Otherwise, any less
    specific method matcher that is registered afterwards might prevent rules that you defined before from being
    applied.
</p>

<p>
    In some scenarios, you might want to define a new method that does not override a method of a super type or an
    interface. This is also possible using Byte Buddy. For this purpose, you can call <code>defineMethod</code> where
    you are able to define a signature. After defining a method, you are ask to provide an
    <code>Instrumentation</code> just as with a method that was identified by a method matcher. Note that method
    matchers that are registered after a method's definition might supersede this instrumentation by the stacking
    principle that we discussed before.
</p>

<p>With <code>defineField</code>, Byte Buddy allows to define fields for a given type. In Java, fields are never
    overriden but can only be <a href="http://en.wikipedia.org/wiki/Variable_shadowing">shadowed</a>. For this reason,
    no field matching or the like is available.
</p>

<p>
    With this knowledge on how methods are selected, we are ready to learn about how we can implement these methods.
    For this purpose, we now look at predefined <code>Instrumentation</code> implementations that ship with Byte Buddy.
    Defining custom instrumentations is discussed in <a href="#customization">the its own section</a> and is only
    intended for users that require very custom method implementations.
</p>

<h4>A closer look at fixed values</h4>

<p>
    We have already seen the <code>FixedValue</code> instrumentation in action. As the name suggests, methods
    that are instrumented by <code>FixedValue</code> simply return a provided object. A class is able to remember
    such an object in two different manners:
</p>

<ul class="colored-list padded">
    <li><span>
            The fixed value is written to a
            <a href="http://en.wikipedia.org/wiki/Java_class_file#The_constant_pool">class's constant pool</a>. The
            constant pool is a section within the Java class file format and contains numerous stateless values that
            describe the properties of any class. The constant pool is mainly required to remember a class's properties
            such as the class's name or the names of its methods. Besides these reflective properties, the constant
            pool has room for storing any string or primitive value that is used within a method or a field of the
            class. Besides strings and primitive values, the class pool can also store references to other types.
        </span></li>
    <li><span>
            The value is stored in a static field of the class. For this to happen, the field must however be assigned
            the given value once the class was loaded into the Java virtual machine. For this purpose, every
            dynamically created class is accompanied by a <code>TypeInitializer</code> which can be configured to
            execute such explicit initialization. When you instruct a <code>DynamicType.Unloaded</code> to be loaded,
            Byte Buddy automatically triggers its type initializer such that the class is ready for use. Therefore,
            you do not normally need to worry about type initializers. However, if you want to load dynamic classes to
            be loaded outside of Byte Buddy, it is important that you run their type initializers manually after these
            classes are loaded. Otherwise, a <code>FixedValue</code> instrumentation would for example return
            <code>null</code> instead of the required value because the static field was never assigned this value.
            Many dynamic types might however not require explicit initialization. A class's type initializer can
            therefore be queried for its liveliness by calling its <code>isAlive</code> method. If you need to trigger
            a <code>TypeInitializer</code> manually, you find it exposed by the <code>DynamicType</code> interface.
        </span></li>
</ul>

<p>
    When you implement a method by <code>FixedValue#value(Object)</code>, Byte Buddy analyzes the parameter's
    type and define it to be stored in the class pool of the dynamic type if possible and otherwise store the value
    in a static field. Note however that the instance that is returned by the selected methods might be of a
    different object identity if the value was stored in the class pool. Therefore, you can instruct Byte Buddy to
    always store an object in a static field by using <code>FixedValue#reference(Object)</code>. The latter method
    is overloaded such that you can provide the field's name as a second argument. Otherwise, a field name is derived
    automatically from the object's hash code. An exception from this behavior is the <code>null</code> value.
    The <code>null</code> value is never stored in a field but is simply represented by its literal expression.
</p>

<p>
    You might wonder about type safety in this context. Obviously, you could define a method to return an invalid
    value:
</p>
<pre class="prettyprint">
new ByteBuddy()
  .subclass(Foo.class)
  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(0))
  .make()
</pre>
<p>
    It would be difficult to prevent this invalid instrumentation by the compiler within Java's type system. Instead,
    Byte Buddy will throw an <code>IllegalArgumentException</code> when the type is created and the illegal assignment
    of an integer to a method that returns a <code>String</code> becomes effective. Byte Buddy tries its best to assure
    that all its created types are legal Java types and <i>fail fast</i> by throwing an exception during the creation
    of an illegal type.
</p>

<p>
    Byte Buddy's assignment behavior is customizable. Again, Byte Buddy only provides a sane default which mimics
    the assignment behavior of the Java compiler. Consequently, Byte Buddy allows an assignment of a type to one
    of its super types and it will also consider to box primitive values or to unbox their wrapper representations. You
    might however implement your own <code>Assigner</code> which is capable of type transformations that are not
    implicit in the Java programming language. We will look into such custom implementations in the
    <a href="#customization">last section of this tutorial</a>. For now, we settle for mentioning that you can define
    such custom assigners by calling <code>withAssigner</code> on any <code>FixedValue</code> instrumentation.
</p>

<h4>Delegating a method call</h4>

<p>
    Discussion of all built-in instrumentations to be completed.
</p>
</div>
<div class="row" id="attributes">
    <h2>Attributes and annotations</h2>

    <p>
        To be completed.
    </p>
</div>
<div class="row" id="cookbook">
    <h2>Cook book</h2>

    <p>
        To be completed.
    </p>
</div>
<div class="row" id="customization">
    <h2>Custom instrumentation</h2>

    <p>
        To be completed.
    </p>
</div>
</div>
</div>

<a href="https://github.com/raphw/byte-buddy">
    <img style="position: absolute; top: 0; left: 0; border: 0; z-index: 9999;"
         src="https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67"
         alt="Fork me on GitHub"
         data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png">
</a>

<div class="row col-md-offset-3 col-md-8">
    <h2>Getting started</h2>

    <p>
        First, you need to create a copy of Byte Buddy on your local machine. Simply clone Byte Buddy's repository
        by using <a href="http://git-scm.com/">git</a> or by cloning it directly on
        <a href="http://www.github.com">GitHub</a>. Once the repository was cloned, you can build the project using
        <a href="http://maven.apache.org/">Maven</a>. From your shell, this might look something like this:
    </p>

<pre class="prettyprint">
git clone https://github.com/raphw/byte-buddy.git
cd byte-buddy
mvn package
</pre>

    <p>
        Before you start to code, make sure that all test cases run successfully. This should be the case at all times
        for the <a href="https://github.com/raphw/byte-buddy/tree/master"><code>master</code></a> branch of Byte Buddy.
        This is hopefully confirmed by our current <a href="https://docs.github.com/en/actions">GitHub Action</a> build which currently is
        <a href="https://github.com/raphw/byte-buddy/actions/workflows/main.yml" class="social-link">
            <img alt="GitHub Actions Workflow Status" src="https://img.shields.io/github/actions/workflow/status/raphw/byte-buddy/main.yml">
        </a>
        and which is constantly monitoring Byte Buddy's latest state. The GitHub Action is configured to compile and test the
        project for the <a href="https://openjdk.org">Open JDK</a> versions 6 and 7 and the
        <a href="https://www.oracle.com/br/java/technologies/downloads/">Oracle JDK</a> versions
        7 and 8. Since some of our tests are creating and loading Java classes, we make sure that the generated classes
        do not use a format that cannot be understood by a specific Java version. If you are making changes to Byte
        Buddy that directly affect the generated byte code, please make sure to sufficiently test your build using
        different Java versions before committing your changes. All this implies that you need to write Java code that
        is compatible to a Java 6 compiler. As a general rule, your code should come with a minimum test coverage of
        90 percent but we prefer thorough tests over tests that only attempt to hit any line. You can always run
        Maven's <code>cobertura:cobertura</code> goal for creating a report on your code's test coverage. Byte Buddy's
        current test coverage is at
        <a href="https://coveralls.io/r/raphw/byte-buddy?branch=master" class="social-link">
            <img src="http://img.shields.io/coveralls/raphw/byte-buddy/master.svg" alt="Byte Buddy code coverage"/>
        </a>. As a more modern alternative, Byte Buddy also supports running mutation tests by running
        <code>org.pitest:pitest-maven:mutationCoverage</code> from Maven. Keep however in mind that running mutation
        tests requires a significant amount of additional runtime compared to computing line coverage. Finally, the
        <code>integration</code> profile for Maven can be activated for scanning the code base for potential
        errors. This profile is always activated on the continuous integration server. The <code>checks</code>
        profile on the other hand aggregates faster-running code checks and is activated by default for any
        Maven build.
    </p>

    <h3>Project modules</h3>
    The project is organized in different modules:
    <p>
    <ul>
        <li>The root project <code>byte-buddy-parent</code> serves as a
        common ground for the configuration of any Byte Buddy module.</li>

        <li>The project's implementation is found
        in the <code>byte-buddy-dep</code> module. This module is configured to rely on a direct dependency onto the
        <a href="http://asm.ow2.org/">ASM</a> library, thus the <i>dev</i> qualifier in the module's name.</li>

        <li>Because the ASM library does <a href="http://asm.ow2.org/doc/faq.html#Q15">not guarantee to respect
        backwards-compatibility</a>, the <code>byte-buddy</code> module repackages the ASM-dependency into Byte Buddy's
        own name space. In doing so, the ASM dependency is moved to <code>net.bytebuddy.jar.asm</code>. This
        dependency-free module does not define sources of its own but relies on the <code>byte-buddy-dep</code> module.
        On its build, all dependencies are resolved and a dependency-free deployment descriptor is created. Further
        information can be found in the section on <a href="#/dependency">how to define a dependency onto Byte Buddy</a>.
        In order to activate this repacking, you need to run the Maven build using the <code>extras</code> profile which
        will furthermore cause the creation of artifacts for source code and javadoc.

        <p>Maven attempts to sign all artifacts. For this to be possible,
        <a href="http://blog.sonatype.com/2010/01/how-to-generate-pgp-signatures-with-maven/">the gpg plugin must be
            configured correctly</a> by the signer.</p>
        </li>

        <li>As another module, <code>byte-buddy-benchmark</code> contains a
        <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> benchmark for measuring Byte Buddy's runtime
        behavior compared to other code generation libraries.</li>

        <li>The <code>byte-buddy-agent</code> module supplies a Java agent that allows to enhance Byte Buddy's general API.</li>
        <li>The <code>byte-buddy-android</code> module
        contains a <code>ClassLoadingStrategy</code> that functions on the Android platform.</li>
        <li>Finally, <code>byte-buddy-android-test</code> defines a test application to apply that strategy. It is only built
        if the <code>android</code> profile is activated as building the module requires an Android SDK.
        </li>
    </ul>
    </p>

    <h2>Architectural overview</h2>

    <p>
        Every code generation framework requires a means of reflecting over types and their members. Byte Buddy
        accesses type information by the <code>TypeDescription</code> interface. This interface offers a similar
        API as the <code>Class</code> type of the Java reflection API and it is possible to represent a loaded Java
        class as a type description using the <code>TypeDescription.ForLoadedType</code> implementation which wraps
        such instances. However, Byte Buddy can also be used for creating Java agents where classes need to be
        manipulated before being loaded. Therefore, Byte Buddy never operates on loaded types but always depends on
        descriptions. All description interfaces are found in the <code>net.bytebuddy.description</code> package.
    </p>

    <p>
        Similarly, Byte Buddy describes generic types as instances of the <code>TypeDescription.Generic</code>
        interface. This interface is richer than Java's equivalent, the <code>Type</code> interface where Byte
        Buddy offers methods for dealing with all sorts of generic types. Functionality that is only supported
        by certain generic types throws an exception when requested for a generic type that does not support
        certain properties. This approach was chosen as a more concise alternative to type casting that is
        required by the Java language. Since most manipulations are performed by visitors, this does however
        not show to be a problem in practice.
    </p>

    <p>
        Byte Buddy builds on top of the <a href="http://asm.ow2.org/">ASM byte code parser</a> which has become the
        de facto standard for byte code parsing in the Java ecosystem. ASM operates with low-level constructs, often
        string values that represent names and descriptors. Byte Buddy offers the <code>StackManipulation</code>
        interface to represent type-safe wrappers around such visitor commands which interact with Byte Buddy's
        description interfaces, extract the required values into the appropriate format and interact with ASM.
        Furthermore, each stack manipulation is aware of its impact on the JVM's operand stack size. This way,
        several stack manipulations can be combined to compute their common requirement on the minimum stack size.
        Several stack manipulations can be grouped to represent a <code>ByteCodeAppender</code>. A byte code appender
        represents a <i>block of code</i> and is required to leave the operand stack empty. Additionally, a byte code
        appender is required to expose the space for local variables it assigns for executing its code. Typically,
        a byte code appender is composed of one or several stack manipulations. All classes related to code generation
        are collected in the <code>net.bytebuddy.implementation.bytecode</code> package.
    </p>

    <p>
        Each byte code appender receives the method it is implementing as an argument to its <code>apply</code> method.
        Furthermore, it receives an ASM visitor for registering the code of the method and an instance of
        <code>Implementation.Context</code>. An implementation context allows the registration of auxiliary types.
        Auxiliary types represent helper types that are required to execute the method. An example of an auxiliary
        type would be a proxy class for invoking another method of the instrumented type as it is used by the
        <code>MethodDelegation</code> instrumentation for the <code>@SuperCall</code> annotation. The implementation
        of <code>Implementation.Context</code> is one of the few mutable classes within Byte Buddy as it accompanies ASM's
        method visitor which is itself mutable. As implementation context is however not being exposed to the public
        API and should neither be exposed by a byte code appender.
    </p>

    <p>
        The top-level construct for representing a method instrumentation is the <code>Implementation</code> interface.
        Instances of this interface are required to yield a <code>ByteCodeAppender</code> given an instrumented type.
        Furthermore, implementations are given a chance to register additional methods, fields or code blocks to be
        run within the static initializer of the instrumented type. Finally, any implementation instance receives
        an instance of <code>Implementation.Target</code> that offers a way of accessing properties of the instrumented
        type that is agnostic of the way that a type is instrumented. For example, it is possible to query for a super
        method invocation on the instrumented type. If a user conducts a subclass instrumentation, this query returns
        an invocation of the actual super method. If a user conducts a type-rebasement, the <code>Implementation.Target</code>
        implementation will however invoke the original code of the rebased method which was copied into another method
        of the same class.
    </p>

    <p>
        In Byte Buddy, any type is constructed by registering properties to a <code>DynamicType.Builder</code>. The
        builder itself constructs an instance of <code>InstrumentedType</code> which extends
        <code>TypeDescription</code> to allow other Byte Buddy's components to reflect over the instrumented type before
        its creation. Furthermore, method and field implementations are registered in a
        <code>MethodRegistry</code> or <code>FieldRegistry</code> accordingly. Finally, all implementations are applied on their matched method
        descriptions by the dynamic type builder, supplying all of its collected information to a
        <code>TypeWriter</code> which interacts with the ASM API for generating a class file.
    </p>

    <h2>Coding conventions</h2>

    <p>
        Byte Buddy aims for full immutability with the exception of mutable classes for interacting with the mostly
        mutable ASM library. Mutable components must however be isolated to the scope of interacting with ASM and
        must not be exposed to an end user. Neither should such instances ever be stored as the value of a field.
        Furthermore, some components, such as Byte Buddy's class loaders, are mutable by their nature of
        being class loaders. All collections within Byte Buddy should however be considered immutable and this property
        must also be enforced when a collection is returned from the public API.
    </p>

    <p>
        All immutable classes must implement appropriate <code>hashCode</code> and <code>equals</code> methods as
        object equality is an important concept for some of Byte Buddy's components. For example, any
        <code>Implementation</code> instance must only prepare the instrumented type a single time because it is not
        legal in Java to register a field with the same name twice. To assure this, any <code>Implementation</code>
        is checked against its equality with previous implementations that already had a chance to prepare the
        instrumented type. If an implementation depends on different objects internally, it is important that all
        these components fulfill their equality contracts. Also, any component should implement an appropriate
        <code>toString</code> method to improve debugging, especially when stack traces of users are posted on help
        forums. With the <code>ObjectPropertyAssertion</code>, Byte Buddy runs unit tests for correct implementations
        of all of these methods.
    </p>

    <p>
        Byte Buddy is strongly object-oriented but takes some inspiration of functional design. Unfortunately, being
        a meta library that is used by many other library developers, Byte Buddy is bound by strong compatibility
        requirements and is compiled on Java 6. To mimic functions, Byte Buddy often implements interfaces by
        enumerations where the enumeration yields a <i>named function</i>. Finally, class files are used as
        containers for related classes rather than packages. Within a class file, it is possible to define a finer
        visibility scope than for top-level classes, for example by allowing for <code>protected</code> classes that
        are only to be seen by subclasses or within the class that is using another class internally. Also, when
        a class is not longer needed as the result of refactoring, this grouping convention makes it easy to
        delete all dependant code.
    </p>

    <p>
        Being a meta library, Byte Buddy tries to offer APIs that are as open to extension as possible as the scope
        of usage cannot be anticipated. Whenever possible, delegation is to be the preferred extension mechanism over
        class extension. <b>All code</b> is to be documented what makes this property
        <a href="https://en.wikipedia.org/wiki/Broken_windows_theory">easier to validate</a> by automatic checks.
        Within Byte Buddy, it is considered a bad practice to use <code>null</code> as a value of a field, parameter
        or as a method return. An exception are the description types that mimic the Java reflection API where null
        values are common. As description instances are exposed to end users, it was decided that the similarity is to
        be considered a more important factor than consistency. All potential <code>null</code> values have to be
        documented on the method. For Byte Buddy, unchecked exceptions are to be preferred over checked exceptions.
    </p>

    <h2>Contribute</h2>

    <p>
        When you have fixed a bug, simply create a <a href="https://github.com/raphw/byte-buddy/pulls">pull request</a>
        on GitHub. We will look into the matter as quickly as possible, once we receive the notification. Make however
        sure that you have accurately described your changes and the fixed issue and please provide a test case that
        reproduces the problem and proves that your fix is working. This makes our work much easier and we will be able
        to apply your patch much quicker. If you add new methods, fields or types, make sure to write some in-code
        documentation that describes their purpose. If you apply performance-relevant changes, please self-critically
        reflect those changes using the <code>byte-buddy-benchmark</code> suite. Finally, please note that new releases
        of Byte Buddy are normally developed in their own branch.
    </p>

    <p>
        If you are contributing a feature, please <a href="https://groups.google.com/forum/#!forum/byte-buddy">get in
        touch</a> before spending a lot of time with it such that we can discuss how your changes are meaningful at
        Byte Buddy's current development state. Byte Buddy is meant to steadily provide more functionality but we do
        not grow its feature set on the expense of its stability and code consistency. However, do not be discouraged
        by this announcement. If you got deep enough into Byte Buddy's source to being able to implement a new awesome
        feature that you want to share, you did for sure give it some thought and we will do our best to merge it into
        our build! Simply come talk to us and we are more than happy to welcome you on board.
    </p>

    <p>
        If you feel like contributing to Byte Buddy's documentation, to its description on this web page or even to the
        structure and design of this web page, you are absolutely welcome to do so! We deeply believe that a thorough
        and up-to-date documentation is the key to a successful project and we will do our best to live up to this
        conviction. Even minor changes are welcome as long as they improve Byte Buddy's accessibility or appearance,
        because in the end, this project was made for its users. Simply clone this web page which is hosted on GitHub
        in the project's <a href="https://github.com/raphw/byte-buddy/tree/gh-pages"><code>gh-pages</code></a> branch.
        The web page was created using <a href="http://angularjs.org/">angular.js</a> and
        <a href="http://getbootstrap.com/">Twitter's Bootstrap</a>.
    </p>

    <h2>Roadmap</h2>

    <p>
        Byte Buddy has reached version <img style="width: 58px; height: 22px; object-fit: cover; object-position: right;" alt="Maven Central Version" src="https://img.shields.io/maven-central/v/net.bytebuddy/byte-buddy?style=flat-square">
        and is considered to be feature-complete aside from two features that are
        not yet supported. With the release of version 1.0 a big emphasis is put on the library's stability and performance
        and new features are added defensively. Naturally, the evolution of the Java programming language and the
        byte code format will require newer releases in the future where it is the goal of Byte Buddy to offer
        a backwards compatible way of manipulating code for older and newer versions of Java. Java 9 support is currently
        still experimental. As of Java 8, Byte Buddy not currently support the following functionality:
    </p>

    <dl>
        <dt>Type inference</dt>
        <dd>
            Generic types can be inferred by the Java compiler. Byte Buddy does not currently offer such functionality. Support
            for type inference would allow for better validation of generic types and for implementing <code>Assigner</code>s
            that consider generic type information. Unfortunately, this feature imposes a lot of work while it is of little
            practical use. For this reason, it is not currently implemented.
        </dd>
    </dl>
</div>
